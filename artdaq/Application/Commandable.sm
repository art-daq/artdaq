// The following block is pasted into the generated state machine
// code. Be careful, because this is likely to make what you write
// language-specific.
%{

%}

%class Commandable
%package artdaq
%header artdaq/Application/Commandable.hh

// compilation and diagram hints:
// java -jar $SMC_HOME/bin/Smc.jar -c++ Commandable.sm
// java -jar $SMC_HOME/bin/Smc.jar -graph -glevel 2 Commandable.sm
// dot -Tpdf Commandable_sm.dot -o Commandable_sm.pdf
// open Commandable_sm.pdf

%start Main::Booted
%map Main // Use a capital letter to start the map name, to generate valid Ruby.

%%

// Note that Default is called a state, but it really isn't. It is a
// place to put a bunch of transition rules that will get used in the
// case of every other state in the map that does *not* provide a 
// specification for handling that transition. In a sense, the Default
// transition is a "base class" for all other states, specifying what 
// should be done if that state doesn't say what to do.

Default
{
  init(pset: fhicl::ParameterSet const&) nil  {badTransition(__func__);}
  start(id: art::RunID, timeout: uint64_t, timestamp: uint64_t)                  nil  {badTransition(__func__);}
  stop      nil  {badTransition(__func__);}
  pause     nil  {badTransition(__func__);}
  resume    nil  {badTransition(__func__);}
  shutdown  nil  {badTransition(__func__);}
  soft_init(pset: fhicl::ParameterSet const&) nil  {badTransition(__func__);}
  reinit(pset: fhicl::ParameterSet const&)    nil  {badTransition(__func__);}
}

Booted
Entry { BootedEnter(); }
//Exit  { BootedExit(); }
{
  init(pset: fhicl::ParameterSet const&)  [ctxt.do_initialize(pset)]
      Initialized/push(InitializedMap::Ready)  {}
  init(pset: fhicl::ParameterSet const&)  nil  {}
  shutdown  Booted  {}
}

Initialized
//Entry { InitializedEnter(); }
//Exit  { InitializedExit(); }
{
  init(pset: fhicl::ParameterSet const&)  [ctxt.do_initialize(pset)]
      Initialized/push(InitializedMap::Ready)  {}
  init(pset: fhicl::ParameterSet const&)  Booted  {}
  shutdown [ctxt.do_shutdown()] Booted  { }
}

%%

%map InitializedMap

%%

Default
{
  init(pset: fhicl::ParameterSet const&)  nil  {badTransition(__func__);}
  start(id: art::RunID, timeout: uint64_t, timestamp: uint64_t)                   nil  {badTransition(__func__);}
  stop      nil  {badTransition(__func__);}
  pause     nil  {badTransition(__func__);}
  resume    nil  {badTransition(__func__);}
  shutdown  nil  {badTransition(__func__);}
  soft_init(pset: fhicl::ParameterSet const&) nil  {badTransition(__func__);}
  reinit(pset: fhicl::ParameterSet const&)    nil  {badTransition(__func__);}
}

Ready
//Entry { ReadyEnter(); }
//Exit  { ReadyExit(); }
{
  start(id: art::RunID, timeout: uint64_t, timestamp: uint64_t)  [ctxt.do_start(id,timeout, timestamp)]  InRun/push(InRunMap::Running)  {}
  start(id: art::RunID, timeout: uint64_t, timestamp: uint64_t)  nil  {}
  init(pset: fhicl::ParameterSet const&)  pop(init, pset)  {}
  soft_init(pset: fhicl::ParameterSet const&)  nil  {do_soft_initialize(pset);}
  shutdown  pop(shutdown)  {}
}

InRun
//Entry { InRunEnter(); }
Exit  { InRunExit(); }
{
  stop  [ctxt.do_stop()]  Ready  {}
  //stop  Error  {}
  //init(pset: fhicl::ParameterSet const&)  [ctxt.do_stop()]  pop(init, pset)  {}
  //init(pset: fhicl::ParameterSet const&)  Error  {}
  //shutdown  [ctxt.do_stop()]  pop(shutdown)  {}
  //shutdown  pop(shutdown)  {}
}

//Error
//{
//  init(pset: fhicl::ParameterSet const&)  pop(init, pset)  {}
//}

%%

%map InRunMap

%%

Default
{
  init(pset: fhicl::ParameterSet const&)  nil  {badTransition(__func__);}
  start(id: art::RunID, timeout: uint64_t, timestamp: uint64_t)                   nil  {badTransition(__func__);}
  stop      nil  {badTransition(__func__);}
  pause     nil  {badTransition(__func__);}
  resume    nil  {badTransition(__func__);}
  shutdown  nil  {badTransition(__func__);}
  soft_init(pset: fhicl::ParameterSet const&) nil  {badTransition(__func__);}
  reinit(pset: fhicl::ParameterSet const&)    nil  {badTransition(__func__);}
}

Running
//Entry { RunningEnter(); }
//Exit  { RunningExit(); }
{
  pause  [ctxt.do_pause()]  Paused  {}
  pause  nil        {}
  stop   pop(stop)  {}
}

Paused
//Entry { PausedEnter(); }
//Exit  { PausedExit(); }
{
  resume  [ctxt.do_resume()]  Running  {}
  resume  nil        {}
  stop    pop(stop)  {}
}

%%
