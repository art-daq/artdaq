#ifndef artdaq_DAQdata_FragmentGenerator_hh
#define artdaq_DAQdata_FragmentGenerator_hh

////////////////////////////////////////////////////////////////////////
// FragmentGenerator is an abstract class that defines the interface for
// obtaining events in artdaq. Subclasses are to override the (private) virtual
// functions; users of FragmentGenerator are to invoke the public
// (non-virtual) functions.
//
// getNext() will be called only from a single thread
////////////////////////////////////////////////////////////////////////

#include "artdaq/DAQdata/Fragments.hh"

namespace artdaq {
  class FragmentGenerator {
  public:

    FragmentGenerator() = default;

    virtual ~FragmentGenerator() = default;

    // Obtain the next collection of Fragments. Return false to indicate
    // end-of-data. Fragments may or may not be in the same event;
    // Fragments may or may not have the same FragmentID. Fragments
    // will all be part of the same Run and SubRun.
<<<<<<< HEAD
    bool getNext(FragmentPtrs & output);


    // This generator produces fragments with what distinct IDs (*not*
    // types)?
    std::vector<Fragment::fragment_id_t> fragmentIDs();

    //
    // State-machine related interface below.
    //

    // Return true if we can only run under control of a state machine,
    // and false otherwise. Clients are *not* permitted to use only part
    // of the state-machine related behavior; if any of the
    // state-machine related functions are used, they must all be used
    // in a consistent fashion.
    bool requiresStateMachine() const;

    // After a call to 'start', all Fragments returned by getNext() will
    // be marked as part of a Run with the given run number, and with
    // subrun number 1. Calling start also resets the event number to 1.
    // After a call to start(), and until a call to stop, getNext() will
    // always return true, even if it returns no fragments.
    void start(int run);

    // After a call to stop(), getNext() will eventually return
    // false. This may not happen for several calls, if the
    // implementation has data to be 'drained' from the system.
    void stop();

    // A call to pause() is advisory. It is an indication that the
    // BoardReader should stop the incoming flow of data, if it can
    // do so.
    void pause();

    // After a call to resume(), the next Fragments returned from
    // getNext() will be part of a new SubRun.
    void resume();
=======
    virtual bool getNext(FragmentPtrs & output) = 0;
>>>>>>> develop-rsi


    // John F., 12/11/13 -- uncertain what the meaning of the comment below is

    // This generator produces fragments with what distinct IDs (*not*
    // types)?
    virtual std::vector<Fragment::fragment_id_t> fragmentIDs() = 0;

  };

}

#endif /* artdaq_DAQdata_FragmentGenerator_hh */
